# Exploit-C

### vulnerabilities:

#### Program 1 (dog.c):
The code is vulnerable because of the **type issue** (i.e. unwanted type conversion) that will allows us to overflow the bluffer in _fread_.

#### Program 2 (dehexify.c):
The code is vulnerable because the lack of **bounds check** allows us to read past the buffer when line 25 (_i += 3_) and then line 29 (_i++_) are 
executed to skip the null bytes in the buffer, which can be leveraged to **extract the canary**. Then, _gets(door)_ does not check the length of the 
input from the user, which allows us to **overflow** the buffer (**making sure to overwrite the canary with itself**).

#### Program 3 (flipper.c):
The code is vulnerable because of an **off-by-one** error. The _for_ loop does not have the proper **bounds check**, which allows us to write one byte 
**past the buffer**. Since the _esp_ is right after the buffer, we can overwrite the last byte (least significant byte) of _esp_ to point inside the 
buffer. We write the address of our environment variable (shellcode) in our buffer, which will eventually result in the execution of our shellcode 
(through the steps outlined below).

#### Program 4 (hound.c):
This program is an example of the classic **time-of-check to time-of-use** exploit. The program checks the size of the file at line 31 but then the file 
is not read till line 38. Through some evil engineering, one can open the file and change the contents (and therefore size) after the check and before 
the read. Consequently, one can then **overflow** the buffer by making the file’s contents larger than _MAX_BUFSIZE_.

#### Program 5 (uplink.c):
This is an example of a **ret2esp** exploit. Since **ASLR** is enabled, our _rip_ will not always be at the same location, and therefore, we cannot overwrite it with a known address. We therefore, take advantage of the fact that the code has the following instruction: **jmp *esp**. When we **overflow** the buffer, we overwrite _rip_ (whose relative location from the buffer we can determine) with this instruction, and put the shellcode at the previous frame’s stack pointer (whose relative address we can also determine).
